#함수 블록 (1번~5번)
# 0번 함수
#ultralytics 패키지 설치 필요
def step0_initialize():
    # Tesseract 실행 파일 경로 설정
    pytesseract_path = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
    # 0. 사전 준비 단계 (Initialization)
    if not os.path.exists(pytesseract_path):
        print("오류!!! 경로 찾을 수 없음")
        return None, None
    pytesseract.pytesseract.tesseract_cmd = pytesseract_path
    print("Tesseract 로드완료")

    # 딥러닝 모델 로드
    try:
        model_b = YOLO('yolov8n.pt')
        print("YOLO 로드완료")
    except Exception as e:
        print("오류!!! 모델을 불러올 수 없음")
        return pytesseract, None

    return pytesseract, model_b

#1번 함수
def step1_ocr_process(roi_frame):
    """
    1. 입력 및 인식 단계
    - 전처리(흑백, 블러, 이진화, 반전) 후 Tesseract로 번호판 추출
    """
    # 의사코드의 전처리 과정: Gray -> Blur -> Otsu -> Not
    gray = cv2.cvtColor(roi_frame, cv2.COLOR_BGR2GRAY)
    gray = cv2.resize(gray, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)
    blur = cv2.GaussianBlur(gray, (5, 5), 0)
    _, thresh = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    processed_img = cv2.bitwise_not(thresh)
    cv2.imshow("Step 1: OCR View", processed_img)

    # Tesseract 분석(kor+eng를 추가하므로써 한글이 숫자로 오인되는 경우 방지)
    car_id_raw = pytesseract.image_to_string(processed_img, lang='kor+eng', config='--psm 7')
    # 한글과 숫자만 남기고 공백, 특수문자 모두 제거
    car_id = re.sub(r'[^0-9가-힣]', '', car_id_raw)
    return car_id.strip()
#2번 함수
# 데이터베이스에서 차량 소유주 정보 조회
def step2_db_check(vehicle_no):
    try:
        conn = sqlite3.connect('parking_system.db')
        cur = conn.cursor()
        # 번호판(vehicle_no)을 기준으로 이름, 동, 선호 구역 조회
        cur.execute("SELECT name, building_no, assigned_seat FROM car_info WHERE vehicle_no=?", (vehicle_no,))
        row = cur.fetchone()
        conn.close()

        if row:
            # 다음 단계(Step 3, 4)에서 사용할 수 있게 딕셔너리로 묶어서 반환
            return {
                'name': row[0],
                'dong': row[1],
                'my_area': row[2]  # 이 정보가 4단계에서 '우리 동 근처'를 찾는 기준이 됨
            }
        return None
    except Exception as e:
        print("DB 에러")
        return None
# [Bridge] 2번에서 가져온 유저 정보와 3번의 YOLO 상태를 결합하는 함수
def bridge_user_to_system(user_data, seat_status):
    if user_data is None:
        return False, "외부 차량입니다. 경비실로 연결합니다."

    return True, user_data, seat_status
#3번 함수
def step3_yolo_analysis(full_frame, model_b):
        """
        YOLO모델을 사용해서, 사람의 상체 위치를 파악, 좌석 점유 현황을 확인하는 부분
        """
        results = model_b.predict(full_frame, verbose=False)
        seat_status = {name: "Empty" for name in config.PARKING_COORDINATES}
        for result in results:
            for box in result.boxes:
                if box.cls == 0: #사람의 유무 판별하는 부분
                    x1,y1,x2,y2 = box.xyxy[0].cpu().numpy()

                    #기준점 추출 (상체 기준? 하체기준? 한다면  몇% 지점?, 20? 30?, 우선 25%로 잡고 시작하지만 변경 될 수도 있음)
                    body_x = int((x1 + x2) / 2)
                    body_y = int(y1 + (y2-y1) * 0.25)
                    #상체 좌표가 설정된 좌석 내에 누가 있는지 확인
                    for seat_name, (sx,sy,sw,sh) in config.PARKING_COORDINATES.items():
                        if sx < body_x < sx + sw and sy < body_y < sy + sh:
                            seat_status[seat_name] = "Seat" # 두 조건이 참 일경우,좌석 사용중
        return seat_status
#4번 함수
def step4_logic_dicision(seat_status):
    """
    입구 기준으로 선착순으로 빈 자리를 찾아서 배정해주는 과정
    """
    empty_seats = [name for name, status in seat_status.items() if status == "Empty"] #현재 비어있는 좌석 목록 추출
    #모든 자리가 찬 경우 경고 표시
    if not empty_seats:
        return "빈 좌석이 없습니다!!!"

    #기준점 설정, 아마도 사진 기준 오른쪽 아래 좌표를 기준점(입구)로 할 거 같음
    config.ENTRANCE_CODE = (100,60) #config 에서 지정한 입구 좌표
    entrance_x, entrance_y = config.ENTRANCE_CODE
    best_seat = None
    min_distance = float('inf')

    #지정한 입구에서 각각의 빈자리까지의 거리 계산
    for seat in empty_seats:
        sx,sy,sw,sh = config.PARKING_COORDINATES[seat]
        seat_center_x = sx + sw/2
        seat_center_y = sy + sh/2
        #가장 가까운 거리 계산(입구 기준 좌석 계산)
        distance  = math.sqrt((entrance_x-seat_center_x)**2 + (entrance_y-seat_center_y)**2)
        #가장 가까운 거리 업데이트
        if distance < min_distance:
            min_distance = distance
            best_seat = seat
    return best_seat #best_seat = 최단 거리(추천 거리)
#5번 함수
def step5_visual_guide(frame, final_destination):
    # final_destination은 4번 함수에서 정해진 번호 값(key)
    #예외 처리(배정된 좌석이 없을 경우)
    if final_destination is None or final_destination not in config.PARKING_COORDINATES:
        msg = "현재 빈 좌석이 없습니다."
        return frame, msg
    # config.PARKING_COORDINATES[]에서 좌석 좌표 값 받아오기
    sx,sy,sw,sh = config.PARKING_COORDINATES[final_destination]
    #사각형 그리기
    pts = np.array([[sx, sy],[sx + sw, sy],[sx + sw, sy + sh],[sx, sy + sh]], np.int32)
    pts = pts.reshape((-1,1,2))
    cv2.polylines(frame,[pts],isClosed=True,color = (0,255,255), thickness=3)

    #자막용 메세지(GUI용)
    guide_msg = f"안내: {final_destination}번 자리로 이동하세요."

    return frame, guide_msg
